---
layout: post
title: Problems
image: /images/problems.jpg
description: There are many ways to approach problems, both in school and work. Here are a few quotes on problem solving that I use every day.
---

![](/images/problems.jpg)

I like problems. I think everyone has a slight liking of problems, or at least a love-hate relationship with them. We love easy things, and yet we also love solving difficult puzzles. I've come to terms with my love of problems, and realize that my life without problems would be pretty pointless.

When faced with a big problem that seems unsolvable, I have a two quotes that I always turn to. They are not necessarily famous quotes, they are just things that I have heard my father and my teacher say. But I think they each embody two schools of thought surrounding problem solving in general.

## Your problems are just complicated versions of a much simpler problem - Tom Taylor

Dr. Tom Taylor was my Mathematical Structures professor and taught us how to write proofs. For the most part, his class was excruciatingly difficult to stay awake through, be he sometimes would have gems like this that made me come to class every day, just in case he dropped one of these nuggets of wisdom. I eventually stopped taking notes on math and only wrote down his off-hand comments. I now have a notebook of life advice from a math professor.

When he said this quote, I believe he was working through a set theoretic proof. The material was difficult for most students, but the crux of the proof just relied on the definition of the union of two sets. He started from the goal of the proof and slowly worked backwards using the information that he knew. The problem seemed impossible, but with his slow-and-steady attitude, he eventually reached a conclusion, just by simplification.

This mentality that problems are inherently simple and our ideas are what make things difficult is very common in our lives. In computer science, there is often a drive to find the most elegant or simple solution to the problem. Multiple choice questions are the kind of question that this process thrives on: there is one true answer and three complications of the problem. By reducing the problem to the most simple form, without any distractions, you will naturally find the answer.

This kind of thinking, a very Plato-esque way of thinking, is contrasted by the more realist approach my father had.

## You can never solve problems, you can just trade them for ones you can handle - Mark Pruitt

This approach to problems is much more common in the world of management, where there are more gray areas, and things become less of a science and more of an art. My father works in energy policy, and whenever you have to deal with such large systems, there are no solutions where everyone is perfectly satisfied. No matter which way you choose, you will be dealing with some sort of problem.

I find this approach to be much more common in the small group of software developers that center around the microservice community. Distributed systems in the presence of software errors are the basis of many academic papers, and the emergent solution that many people have found when dealing with problems that don't have a perfect solution. If you've been snowed in and you want some heavy reading on this subject in terms of computer science, check out the [founding paper on the Erlang language](http://www.erlang.org/download/armstrong_thesis_2003.pdf). The point boils down to this philosophy:

> Tasks are ordered by complexity. The top level task is the most
complex, when all the goals in the top level task can be achieved
then the system should function perfectly. Lower level tasks should
still allow the system to function in an acceptable manner, though it
may ocer a reduced level of service.

Thus everything in Erlang is built around the idea of trade-offs. I do not know which philosopher would say that things are inherently based on trade-offs. It would probably be Adam Smith or Vilfredo Pareto, who where economists rather than philosophers.

So there they are, the two approaches to software problems: The mathematician approach and the economist approach. How do you approach things?